#!/usr/bin/python
 
import time
from subprocess import call
from os import system
import os
import decimal
import numpy as np
from numpy import *
import math
import inputFile

def error_message(number):
	if(number<=1):
		print("Warning!!!")  
		print("Increase the number of blocks in your computation!!!")
		exit(0)

def errorpropagation(mean, data):
	ndim   = len(data)
	error = np.std(data,ddof=0)/sqrt(ndim)
	return error
	
def maxError_byBining(mean, data, workingNdim):
	error_message(workingNdim)
	error    = np.zeros(workingNdim)
	i        = 0
	error[0] = errorpropagation(mean, data)
	for i in range(1,workingNdim):
		ndim         = int(len(data)/2)
		data1        = np.zeros(ndim)

		for j in range(ndim):
			data1[j] = 0.5*(data[2*j]+data[2*j+1])

		data         = data1
		error[i]     = errorpropagation(mean,data)
	return np.max(error)

def makeexecutionfile(src_dir,TypeCal,ENT_TYPE, source_dir_exe):
	print("#-----------------------Compilation started--------------------#")
	execution_file_dir  = source_dir_exe
	os.chdir(execution_file_dir)
	call(["make", "clean"])
	if (TypeCal == "PIGS"):
		call(["cp", "Makefile-PIGS", "Makefile"])
	if (TypeCal == "ENT"):
		if (ENT_TYPE == "SWAPTOUNSWAP"):
			call(["cp", "Makefile-PIGSENT", "Makefile"])
		if (ENT_TYPE == "BROKENPATH"):
			call(["cp", "Makefile-PIGSENTBROKENPATH", "Makefile"])
		if (ENT_TYPE == "SWAP"):
			call(["cp", "Makefile-PIGSENTSWAP", "Makefile"])
	if (TypeCal == "PIMC"):
		call(["cp", "Makefile-PIMC", "Makefile"])
	call(["make"])
	print("#-----------------------Compilation ended here--------------------#")
	print("")
	print("")
	print("")
	print("")
	print("")
	print("")
	os.chdir(src_dir)

def compile_rotmat(source_dir_exe, input_dir):
	path_enter_linden = source_dir_exe+"linear_prop/"
	os.chdir(path_enter_linden)
	call(["make", "clean"])
	call(["make"])
	path_exit_linden  = input_dir
	os.chdir(path_exit_linden)

def compile_cagepot(source_dir_exe, input_dir):
	path_enter_cagepot = source_dir_exe+"tabulated_potential/"
	os.chdir(path_enter_cagepot)
	call(["make", "clean"])
	call(["make"])
	path_exit_cagepot  = source_dir_exe+input_dir
	os.chdir(path_exit_cagepot)

def jackknife(mean,data):
	ai            = [((np.sum(data) - data[j])/(len(data) - 1.0)) for j in range(len(data))]
	deviation     = ai - mean
	devsq         = np.multiply(deviation,deviation)
	error         = sqrt(np.sum(devsq)*(len(data)-1.0)/len(data))
	return error

def levels(number):
	for j in range (10):
		jj=pow(2,j)

		if jj <= (number-1):
			level = j
		else:
			break
	return level

def dropzeros(number):
    mynum          = decimal.Decimal(number).normalize()
    # e.g 22000 --> Decimal('2.2E+4')
    return mynum.__trunc__() if not mynum % 1 else float(mynum)

def GetBconst(molecule_rot):
	'''
	This function calculates rotational Bconstant for linear rotor
	'''
	'''
	autocminverse  = 2.1947463137e+5
	energyj0       = -36117.5942855
	energyj1       = -35999.1009407
	bconst         = 0.5*(energyj1-energyj0)     # in cm^-1
	'''
	if (molecule_rot == "HF"):
		#bconst	   = 20.9561                     # in cm^-1  and it is  taken from http://webbook.nist.gov/cgi/inchi?ID=C7664393&Mask=1000#Diatomic
		bconst	   = 20.561                      # in cm^-1  and it is  taken from J. Opt. Soc. Am. Vol. 57, issue 12, page 1464, year 1967
	if (molecule_rot == "H2"):
		bconst	   = 60.853
	return bconst

def replace(string_old, string_new, file1, file2):
	'''
	This function replaces old string by new string
	'''
	f1             = open(file1, 'r')
	f2             = open(file2, 'w')
	for line in f1:
		f2.write(line.replace(string_old, string_new))
	f1.close()
	f2.close()

def beads(tau,beta):
	'''
	This function determins number of beads
	'''
	numbbeads1     =beta/tau+1
	numbbeads2     = int(round(numbbeads1,0))
	if (numbbeads2 % 2 == 0):
		numbbeads2 = numbbeads2 + 1
	return numbbeads2

def inputstr(numbbeads,tau,temperature):
	'''
	This function gives us the exact values of the agruments
	'''
	argu1          = "%7d"   % numbbeads
	argu2          = "%20.15f" % tau
	argu3          = "%7.5f" % temperature
	output ="numbbeads = "+argu1+", tau = "+argu2+", temperature = "+argu3+"\n"
	return output

def GetAverageEnergy(TypeCal,numbbeads,variable,final_dir_in_work,preskip,postskip):
	'''
	This function gives us the output 
	'''
	print("")
	print("All the output files generated by MoRiBs are stored in - ")
	print(final_dir_in_work)
	if (TypeCal == "PIMC"):
		col_block, col_kin, col_rot, col_pot, col_tot = genfromtxt(final_dir_in_work+"/results/output.eng",unpack=True, usecols=[0,1,2,3,4], skip_header=preskip, skip_footer=postskip)
		print("")
		print("array size of output.eng")
		print(len(col_tot))
	
		workingNdim   = int(math.log(len(col_tot))/math.log(2))
		trunc         = int(len(col_tot)-2**workingNdim)
	
		col_kin       = col_kin[trunc:]
		col_rot       = col_rot[trunc:]
		col_pot       = col_pot[trunc:]
		col_tot       = col_tot[trunc:]

		mean_kin      = np.mean(col_kin)
		mean_rot      = np.mean(col_rot)
		mean_pot      = np.mean(col_pot)
		mean_tot      = np.mean(col_tot)

		error_kin     = maxError_byBining(mean_kin, col_kin, workingNdim-6)
		error_rot     = maxError_byBining(mean_rot, col_rot, workingNdim-6)
		error_pot     = maxError_byBining(mean_pot, col_pot, workingNdim-6)
		error_tot     = maxError_byBining(mean_tot, col_tot, workingNdim-6)

		output  = '{0:10d}{1:20.5f}{2:20.5f}{3:20.5f}{4:20.5f}{5:20.5f}{6:20.5f}{7:20.5f}{8:20.5f}{9:20.5f}'.format(numbbeads, variable, mean_kin, mean_rot, mean_pot, mean_tot, error_kin, error_rot, error_pot, error_tot)
		output  += "\n"

	if (TypeCal == "PIGS"):
		col_block, col_rot, col_rot1, col_pot, col_tot = genfromtxt(final_dir_in_work+"/results/output.eng",unpack=True, usecols=[0,1,2,3,4], skip_header=preskip, skip_footer=postskip)
		print("")
		print("array size of output.eng")
		print(len(col_tot))
	
		workingNdim   = int(math.log(len(col_tot))/math.log(2))
		trunc         = int(len(col_tot)-2**workingNdim)
	
		col_rot       = col_rot[trunc:]
		col_rot1      = col_rot1[trunc:]
		col_pot       = col_pot[trunc:]
		col_tot       = col_tot[trunc:]

		mean_rot      = np.mean(col_rot)
		mean_rot1     = np.mean(col_rot1)
		mean_pot      = np.mean(col_pot)
		mean_tot      = np.mean(col_tot)

		error_rot     = maxError_byBining(mean_rot, col_rot, workingNdim-6)
		error_rot1    = maxError_byBining(mean_rot1, col_rot1, workingNdim-6)
		error_pot     = maxError_byBining(mean_pot, col_pot, workingNdim-6)
		error_tot     = maxError_byBining(mean_tot, col_tot, workingNdim-6)

		output  = '{0:10d}{1:20.5f}{2:20.5f}{3:20.5f}{4:20.5f}{5:20.5f}{6:20.5f}{7:20.5f}{8:20.5f}{9:20.5f}'.format(numbbeads, variable, mean_rot, mean_rot1, mean_pot, mean_tot, error_rot, error_rot1, error_pot, error_tot)
		output  += "\n"

	if (TypeCal == "ENT"):
		col_block, col_rot, col_rot1, col_pot, col_tot = genfromtxt(final_dir_in_work+"/results/output.eng",unpack=True, usecols=[0,1,2,3,4], skip_header=preskip, skip_footer=postskip)
		print("")
		print("array size of output.eng")

		workingNdim   = int(math.log(len(col_tot))/math.log(2))
		trunc         = int(len(col_tot)-2**workingNdim)
	
		col_rot       = col_rot[trunc:]
		col_rot1      = col_rot1[trunc:]
		col_pot       = col_pot[trunc:]
		col_tot       = col_tot[trunc:]

		mean_rot      = np.mean(col_rot)
		mean_rot1     = np.mean(col_rot1)
		mean_pot      = np.mean(col_pot)
		mean_tot      = np.mean(col_tot)

		error_rot     = maxError_byBining(mean_rot, col_rot, workingNdim-6)
		error_rot1    = maxError_byBining(mean_rot1, col_rot1, workingNdim-6)
		error_pot     = maxError_byBining(mean_pot, col_pot, workingNdim-6)
		error_tot     = maxError_byBining(mean_tot, col_tot, workingNdim-6)

		output  = '{0:10d}{1:20.5f}{2:20.5f}{3:20.5f}{4:20.5f}{5:20.5f}{6:20.5f}{7:20.5f}{8:20.5f}{9:20.5f}'.format(numbbeads, variable, mean_rot, mean_rot1, mean_pot, mean_tot, error_rot, error_rot1, error_pot, error_tot)
		output  += "\n"
	return output

def GetAverageOrientation(numbbeads,variable,final_dir_in_work,preskip,postskip):
	'''
	This function gives us the output 
	'''
	col_block, col_costheta, col_compx, col_compy, col_compz, col_abs_compx, col_abs_compy, col_abs_compz = genfromtxt(final_dir_in_work+"/results/output.dof",unpack=True, usecols=[0,1,2,3,4,5,6,7], skip_header=preskip, skip_footer=postskip)
	'''
	fd             = open(final_dir_in_work+'/results/output_instant.dof', 'rb')
	shape          = (-1,5) 
	dataBin        = np.fromfile(file=fd, count = -1, dtype=np.float64).reshape(shape)
	col_block      = dataBin[:,0]
	col_costheta   = dataBin[:,1]
	col_compx      = dataBin[:,2]
	col_compy      = dataBin[:,3]
	col_compz      = dataBin[:,4]
	'''
	workingNdim   = int(math.log(len(col_block))/math.log(2))
	trunc         = int(len(col_block)-2**workingNdim)
	
	col_costheta  = col_costheta[trunc:]
	col_compx     = col_compx[trunc:]
	col_compy     = col_compy[trunc:]
	col_compz     = col_compz[trunc:]

	mean_costheta  = np.mean(col_costheta)
	mean_compx     = np.mean(col_compx)
	mean_compy     = np.mean(col_compy)
	mean_compz     = np.mean(col_compz)
	error_costheta = maxError_byBining(mean_costheta, col_costheta, workingNdim-6)
	error_compx    = maxError_byBining(mean_compx, col_compx, workingNdim-6)
	error_compy    = maxError_byBining(mean_compy, col_compy, workingNdim-6)
	error_compz    = maxError_byBining(mean_compz, col_compz, workingNdim-6)

	col_abs_compx  = col_abs_compx[trunc:]
	col_abs_compy  = col_abs_compy[trunc:]
	col_abs_compz  = col_abs_compz[trunc:]
	mean_abs_compx = np.mean(col_abs_compx)
	mean_abs_compy = np.mean(col_abs_compy)
	mean_abs_compz = np.mean(col_abs_compz)
	error_abs_compx= maxError_byBining(mean_abs_compx, col_abs_compx, workingNdim-6)
	error_abs_compy= maxError_byBining(mean_abs_compy, col_abs_compy, workingNdim-6)
	error_abs_compz= maxError_byBining(mean_abs_compz, col_abs_compz, workingNdim-6)


	'''
	col_sqcompx   = np.square(col_compx)
	col_sqcompy   = np.square(col_compy)
	col_sqcompz   = np.square(col_compz)
	mean_sqcompx  = np.mean(col_sqcompx)
	mean_sqcompy  = np.mean(col_sqcompy)
	mean_sqcompz  = np.mean(col_sqcompz)
	error_sqcompx = 2.0*mean_compx*error_compx
	error_sqcompy = 2.0*mean_compy*error_compy
	error_sqcompz = 2.0*mean_compz*error_compz
	'''

	output  = '{0:10d}{1:15.5f}{2:15.5f}{3:15.5f}{4:15.5f}{5:15.5f}{6:15.5f}{7:15.5f}{8:15.5f}{9:15.5f}{10:15.5f}{11:15.5f}{12:15.5f}{13:15.5f}{14:15.5f}{15:15.5f}'.format(numbbeads, variable, mean_costheta, mean_compx, mean_compy, mean_compz, mean_abs_compx, mean_abs_compy, mean_abs_compz, error_costheta, error_compx, error_compy, error_compz, error_abs_compx, error_abs_compy, error_abs_compz)
	output  += "\n"
	return output

def GetAverageCorrelation(CORRELATION,numbmolecules,numbbeads,variable,final_dir_in_work,preskip,postskip):
	'''
	This function gives us the output 
	'''
	ndim              = int(numbmolecules*(numbmolecules+1)/2)
	output            = '{0:10d}{1:15.5f}'.format(numbbeads, variable)

	if (CORRELATION == "TotalCorr"):
		loopStart     = 1

	if (CORRELATION == "XCorr"):
		loopStart     = ndim+1

	if (CORRELATION == "YCorr"):
		loopStart     = 2*ndim+1

	if (CORRELATION == "ZCorr"):
		loopStart     = 3*ndim+1

	if (CORRELATION == "XYCorr"):
		loopStart     = 4*ndim+1

	for i in range(ndim):
		col           = loopStart+i
		print(col)
		comp          = genfromtxt(final_dir_in_work+"/results/outputDipole.corr",unpack=True, usecols=[col], skip_header=preskip, skip_footer=postskip)

		workingNdim   = int(math.log(len(comp))/math.log(2))
		trunc         = int(len(comp)-2**workingNdim)
	
		comp          = comp[trunc:]

		mean_comp  = np.mean(comp)
		error_comp = maxError_byBining(mean_comp, comp, workingNdim-6)
		output 		 += '     '+str(mean_comp)+'     '+str(error_comp)

	output  		 += "\n"
	return output

def fmtAverageEnergy(TypeCal,status,variable):
	'''
	This function gives us the output 
	'''
	if variable == "Rpt":
		unit = "(Angstrom)"
	else:
		unit = "(1/K)"

	if status == "analysis":
		output     ="#"
		if (TypeCal == "PIMC"):
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}{6:^20}{7:^20}{8:^20}{9:^20}'.format('Beads', variable, 'Avg. Translational', 'Avg. rotational', 'Avg. Potential', 'Avg. Total', 'Error of Translational', 'Error of Rotational', 'Error of Potential', 'Error of Total')
		if (TypeCal == "PIGS"):
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}{6:^20}{7:^20}{8:^20}{9:^20}'.format('Beads', variable, 'Avg. rotational', 'Avg. (E - V)', 'Avg. Potential', 'Avg. Total', 'Error of Rotational', 'Error of (E - V)', 'Error of Potential', 'Error of Total')
		if (TypeCal == "ENT"):
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}{6:^20}{7:^20}{8:^20}{9:^20}'.format('Beads', variable, 'Avg. rotational', 'Avg. (E - V)', 'Avg. Potential', 'Avg. Total', 'Error of Rotational', 'Error of (E - V)', 'Error of Potential', 'Error of Total')
		output    +="\n"
		output    +="#"
		output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}{6:^20}{7:^20}{8:^20}{9:^20}'.format('', (str(unit)), 'Energy (K)', 'Energy (K)', 'Energy (K)', 'Energy (K)', 'Energy (K)', 'Energy (K)', 'Energy (K)', 'Energy (K)')
		output    +="\n"
		output    += '{0:=<200}'.format('#')
		output    +="\n"
		return output

def fmtAverageOrientation(status,variable):
	'''
	This function gives us the output 
	'''
	if variable == "Rpt":
		unit = "(Angstrom)"
	else:
		unit = "(1/K)"

	if status == "analysis":
		output     ="#"
		output    += '{0:^15}{1:^15}{2:^15}{3:^15}{4:^15}{5:^15}{6:^15}{7:^15}{8:^15}{9:^15}'.format('Beads', variable, '<sum of ei.ej>', '< x >', '< y >', '< z >', '< |x| >', '< |y| >', '< |z| >', 'Errors')
		output    +="\n"
		output    +="#"
		output    += '{0:^15}{1:^15}{2:^15}{3:^15}{4:^15}{5:^15}{6:^15}{7:^15}{8:^15}{9:^15}'.format('', (str(unit)), '', '', '', '', '', '', '', '')
		#output    +="\n"
		#output    +="#"
		#output    += '{0:^15}{1:^15}{2:^15}{3:^15}{4:^15}{5:^15}{6:^15}{7:^15}{8:^15}{9:^15}{10:^15}{11:^15}{12:^15}{13:^15}{14:^15}{15:^15}'.format('(1)', '(2)', '(3)', '(4)', '(5)', '(6)', '(7)', '(8)', '(9)', '(10)', '(11)', '(12)', '(13)', '(14)', '(15)', '(16)')
		output    +="\n"
		#output    += '{0:=<250}'.format('#')
		output    += '{0:=<190}'.format('#')
		output    +="\n"

	return output

def GetAverageEntropy(numbbeads,variable,final_dir_in_work,preskip,postskip,ENT_TYPE):
	'''
	This function gives us the output 
	'''
	print("")
	print("All the output files generated by MoRiBs are stored in - ")
	print(final_dir_in_work)
	if ENT_TYPE == "SWAPTOUNSWAP":
		col_block, col_nm, col_dm = genfromtxt(final_dir_in_work+"/results/output.rden",unpack=True, usecols=[0,1,2], skip_header=preskip, skip_footer=postskip)
		workingNdim  = int(math.log(len(col_nm))/math.log(2))
		trunc        = int(len(col_nm)-2**workingNdim)
		print(workingNdim)
	
		col_nm       = col_nm[trunc:]
		col_dm       = col_dm[trunc:]
		mean_nm      = np.mean(col_nm)
		mean_dm      = np.mean(col_dm)
		purity       = mean_nm/mean_dm
		mean_EN      = -log(purity)

		error_nm     = maxError_byBining(mean_nm, col_nm, workingNdim-6) 
		error_dm     = maxError_byBining(mean_dm, col_dm, workingNdim-6)
		error_purity = abs(purity)*sqrt((error_dm/mean_dm)*(error_dm/mean_dm) + (error_nm/mean_nm)*(error_nm/mean_nm))
		error_EN     = sqrt((error_dm/mean_dm)*(error_dm/mean_dm) + (error_nm/mean_nm)*(error_nm/mean_nm))

		output  = '{0:10d}{1:20.5f}{2:20.5f}{3:20.5f}{4:20.5f}{5:20.5f}{6:20.5f}{7:20.5f}{8:20.5f}{9:20.5f}'.format(numbbeads, variable, mean_nm, mean_dm, purity, mean_EN, error_nm, error_dm, error_purity, error_EN)
		output  += "\n"

	if ENT_TYPE == 'BROKENPATH':
		col_block, col_nm, col_dm = genfromtxt(final_dir_in_work+"/results/output.rden",unpack=True, usecols=[0,1,2], skip_header=preskip, skip_footer=postskip)
		workingNdim  = int(math.log(len(col_nm))/math.log(2))
		trunc        = int(len(col_nm)-2**workingNdim)
	
		col_nm       = col_nm[trunc:]
		col_dm       = col_dm[trunc:]
		mean_nm      = np.mean(col_nm)
		mean_dm      = np.mean(col_dm)
		mean_EN      = -log(mean_nm/mean_dm)

		error_nm     = maxError_byBining(mean_nm, col_nm, workingNdim-6) 
		error_dm     = maxError_byBining(mean_dm, col_dm, workingNdim-6)
		error_EN     = sqrt((error_dm/mean_dm)*(error_dm/mean_dm) + (error_nm/mean_nm)*(error_nm/mean_nm))

		output  = '{0:10d}{1:20.5f}{2:20.5f}{3:20.5f}{4:20.5f}{5:20.5f}{6:20.5f}{7:20.5f}'.format(numbbeads, variable, mean_nm, mean_dm, mean_EN, error_nm, error_dm, error_EN)
		output  += "\n"

	if ENT_TYPE == "SWAP":
		col_block, col_nm, col_dm, col_TrInv = genfromtxt(final_dir_in_work+"/results/output.rden",unpack=True, usecols=[0,1,2,3], skip_header=preskip, skip_footer=postskip)
		workingNdim  = int(math.log(len(col_nm))/math.log(2))
		trunc        = int(len(col_nm)-2**workingNdim)
	
		col_nm       = col_nm[trunc:]
		col_dm       = col_dm[trunc:]
		mean_nm      = np.mean(col_nm)
		mean_dm      = np.mean(col_dm)
		mean_TrInv   = np.mean(col_TrInv)
		purity       = 1.0/mean_TrInv
		mean_EN      = -log(purity)

		error_nm     = maxError_byBining(mean_nm, col_nm, workingNdim-6) 
		error_dm     = maxError_byBining(mean_dm, col_dm, workingNdim-6)
		error_TrInv  = np.std(col_TrInv,ddof=1)/sqrt(len(col_block))
		error_purity = abs(1.0/(mean_TrInv*mean_TrInv))*error_TrInv
		error_EN     = abs(1.0/mean_TrInv)*error_TrInv #Write the proper equation

		output  = '{0:10d}{1:20.5f}{2:20.5f}{3:20.5f}{4:20.5f}{5:20.5f}{6:20.5f}{7:20.5f}{8:20.5f}{9:20.5f}'.format(numbbeads, variable, mean_nm, mean_dm, purity, mean_EN, error_nm, error_dm, error_purity, error_EN)
		output  += "\n"

	if ENT_TYPE == "UNSWAP":
		col_block, col_nm, col_dm, col_Tr = genfromtxt(final_dir_in_work+"/results/output.rden",unpack=True, usecols=[0,1,2,3], skip_header=preskip, skip_footer=postskip)
		workingNdim  = int(math.log(len(col_nm))/math.log(2))
		trunc        = int(len(col_nm)-2**workingNdim)
	
		col_nm       = col_nm[trunc:]
		col_dm       = col_dm[trunc:]
		mean_nm      = np.mean(col_nm)
		mean_dm      = np.mean(col_dm)
		mean_purity  = np.mean(col_Tr)
		mean_EN      = -log(mean_Tr)

		error_nm     = maxError_byBining(mean_nm, col_nm, workingNdim-6) 
		error_dm     = maxError_byBining(mean_dm, col_dm, workingNdim-6)
		error_purity = np.std(col_Tr,ddof=1)/sqrt(len(col_block))
		error_EN     = abs(1.0/mean_TrInv)*error_TrInv #Write the proper equation

		output  = '{0:10d}{1:20.5f}{2:20.5f}{3:20.5f}{4:20.5f}{5:20.5f}{6:20.5f}{7:20.5f}{8:20.5f}{9:20.5f}'.format(numbbeads, variable, mean_nm, mean_dm, mean_purity, mean_EN, error_nm, error_dm, error_purity, error_EN)
		output  += "\n"

	return output

def fmtAverageEntropy(status,variable,ENT_TYPE):
	'''
	This function gives us the output 
	'''
	if variable == "Rpt":
		unit = "(Angstrom)"
	else:
		unit = "(1/K)"

	if status == "analysis":
		output     ="#"
		if ENT_TYPE == 'SWAPTOUNSWAP':
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}{6:^20}{7:^20}{8:^20}{9:^20}'.format('Beads', variable+'  (1/K)', '<Nm>', '<Dm>', 'Avg. Purity', 'Entropy', 'Error of Nm', 'Error of Dm', 'Error of Purity', 'Error of Entropy')
		if ENT_TYPE == 'BROKENPATH':
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}{6:^20}{7:^20}'.format('Beads', variable+'  (1/K)', '<Nm>', '<Dm>', 'Entropy', 'Error of Nm', 'Error of Dm', 'Error of Entropy')
		if ENT_TYPE == 'SWAP':
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}{6:^20}{7:^20}{8:^20}{9:^20}'.format('Beads', variable+'  (1/K)', '<Nm>', '<Dm>', 'Avg. Purity', 'Entropy', 'Error of Nm', 'Error of Dm', 'Error of Purity', 'Error of Entropy')
		if ENT_TYPE == 'REGULARPATH':
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}{6:^20}{7:^20}{8:^20}{9:^20}'.format('Beads', variable+'  (1/K)', '<Nm>', '<Dm>', 'Avg. Purity', 'Entropy', 'Error of Nm', 'Error of Dm', 'Error of Purity', 'Error of Entropy')
		output    +="\n"
		output    += '{0:=<205}'.format('#')
		output    +="\n"
		return output

def GetAverageEntropyRT(maxloop, TypeCal, molecule_rot, TransMove, RotMove, variableName, Rpt, gfact, dipolemoment, parameterName, parameter, numbblocks, numbpass, numbmolecules1, molecule, ENT_TYPE, preskip, postskip, extra_file_name, dir_output, variable, crystal, final_results_path):
	'''
	This function gives us Renyi entropy of a many-rotors system simulated by Ratio trick algorithm.
	'''
	list_nb = inputFile.Getbeads(TypeCal, variableName)
	ndim_beads = int(len(list_nb))
	purity_combo      = np.zeros(ndim_beads,dtype = 'f')
	err_purity_combo  = np.zeros(ndim_beads,dtype = 'f')
	entropy_combo     = np.zeros(ndim_beads,dtype = 'f')
	err_entropy_combo = np.zeros(ndim_beads,dtype = 'f')
	col_beads         = np.zeros(ndim_beads,dtype = int)
	col_var           = np.zeros(ndim_beads,dtype = 'f')
	ii = 0
	for iBead in list_nb:
		if ((iBead % 2) != 0):
			value     = iBead
		else:
			value     = iBead+1

		if (variableName == "beta"):
			beta      = parameter*(value - 1)
			variable  = beta
		if (variableName == "tau"):
			tau       = parameter/(value-1)
			variable  = tau

		numbbeads     = value

		condition = True
		col_purity= np.zeros((maxloop),dtype = 'f')
		col_err_purity= np.zeros((maxloop),dtype = 'f')
		for partition in range(1,maxloop+1):
			file1_name = GetFileNameSubmission(TypeCal, molecule_rot, TransMove, RotMove, Rpt, gfact, dipolemoment, parameterName, parameter, numbblocks, numbpass, numbmolecules1, molecule, ENT_TYPE, partition, extra_file_name, crystal)
			folder_run = file1_name+str(numbbeads)
			final_dir_in_work = dir_output+folder_run
			dir = os.path.dirname(final_dir_in_work+"/")
			if not os.path.exists(dir):
				condition = False
				break	
			col_block, col_nm, col_dm = genfromtxt(final_dir_in_work+"/results/output.rden",unpack=True, usecols=[0,1,2], skip_header=preskip, skip_footer=postskip)
			if (numbmolecules1 > 2):
				workingNdim  = int(math.log(len(col_nm))/math.log(2))
				trunc        = int(len(col_nm)-2**workingNdim)
				mean_nm = np.mean(col_nm)
				mean_dm = np.mean(col_dm)
				err_nm  = maxError_byBining(mean_nm, col_nm, workingNdim-6) 
				err_dm  = maxError_byBining(mean_dm, col_dm, workingNdim-6)

				col_purity[partition-1]      = mean_nm/mean_dm
				col_err_purity[partition-1]  = abs(mean_nm/mean_dm)*sqrt((err_dm/mean_dm)*(err_dm/mean_dm) + (err_nm/mean_nm)*(err_nm/mean_nm))
			
		if (condition == True):

			workingNdim  = int(math.log(len(col_nm))/math.log(2))
			trunc        = int(len(col_nm)-2**workingNdim)

			if (numbmolecules1 > 2):

				purity_block = np.prod(col_purity,axis=0)
				purity       = purity_block
				entropy      = -log(purity)
				err_purity   = abs(purity)*sqrt(np.sum(np.square(np.divide(col_err_purity,col_purity))))
				err_entropy  = abs(err_purity)/purity
			else:
				col_nm       = col_nm[trunc:]
				col_dm       = col_dm[trunc:]
				mean_nm      = np.mean(col_nm)
				mean_dm      = np.mean(col_dm)
				err_nm       = maxError_byBining(mean_nm, col_nm, workingNdim-6) 
				err_dm       = maxError_byBining(mean_dm, col_dm, workingNdim-6)

				purity       = mean_nm/mean_dm
				entropy      = -log(purity)
				err_purity   = abs(purity)*sqrt((err_dm/mean_dm)*(err_dm/mean_dm) + (err_nm/mean_nm)*(err_nm/mean_nm))
				err_entropy  = abs(err_purity)/purity

			purity_combo[ii]      = purity
			entropy_combo[ii]     = entropy
			col_beads[ii]         = numbbeads
			col_var[ii]           = variable
			err_purity_combo[ii]  = err_purity
			err_entropy_combo[ii] = err_entropy
			ii = ii+1

	FileAnalysis = GetFileNameAnalysis(TypeCal, True, molecule_rot, TransMove, RotMove, variableName, Rpt, gfact, dipolemoment, parameterName, parameter, numbblocks, numbpass, numbmolecules1, molecule, ENT_TYPE, preskip, postskip, extra_file_name, final_results_path, partition)
	np.savetxt(FileAnalysis.SaveEntropyRT, np.transpose([col_beads[:ii], col_var[:ii], purity_combo[:ii], entropy_combo[:ii], err_purity_combo[:ii], err_entropy_combo[:ii]]), fmt=['%5d','%10.6f', '%10.6f', '%10.6f', '%10.6f', '%10.6f'])
	SavedFile = FileAnalysis.SaveEntropyRT
	FileCheck(TypeCal,list_nb,variableName,SavedFile)
	call(["cat", FileAnalysis.SaveEntropyRT])
	print("Successful execution!")

def fmtAverageEntropyRT(status,variable,ENT_TYPE):
	'''
	This function gives us the output 
	'''
	if variable == "Rpt":
		unit = "(Angstrom)"
	else:
		unit = "(1/K)"

	if status == "analysis":
		output     ="#"
		if ENT_TYPE == 'SWAPTOUNSWAP':
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}'.format('Beads', variable+'  (1/K)', 'Avg. Purity', 'Entropy', 'Error of Purity', 'Error of Entropy')
		if ENT_TYPE == 'BROKENPATH':
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}'.format('Beads', variable+'  (1/K)', 'Entropy', 'Error of Entropy')
		if ENT_TYPE == 'SWAP':
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}'.format('Beads', variable+'  (1/K)', 'Avg. Purity', 'Entropy', 'Error of Purity', 'Error of Entropy')
		if ENT_TYPE == 'REGULARPATH':
			output    += '{0:^15}{1:^20}{2:^20}{3:^20}{4:^20}{5:^20}'.format('Beads', variable+'  (1/K)', 'Avg. Purity', 'Entropy', 'Error of Purity', 'Error of Entropy')
		output    +="\n"
		output    += '{0:=<115}'.format('#')
		output    +="\n"
		return output

def GetInput(temperature,numbbeads,numbblocks,numbpass,molecule_rot,numbmolecules,distance,level,step,step_trans,gfact,dipolemoment,particleA, Restart1, numbblocks_Restart1, crystal, RotorType, TransMove, RotMove):
	'''
	This function modifies parameters in qmc_run.input
	'''
	replace("temperature_input", str(temperature),            "qmc_run.input", "qmc2.input")
	replace("numbbeads_input", str(numbbeads),                "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	if TransMove:
		replace("#TRANSLATION", "TRANSLATION", "qmc2.input", "qmc3.input")
	else:
		replace("#TRANSLATION", "#TRANSLATION", "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	if RotMove:
		replace("cal_type_input", "ROTATION", "qmc2.input", "qmc3.input")
	else:
		replace("cal_type_input", "#ROTATION", "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	if Restart1:
		replace("numbblocks_input", str(numbblocks_Restart1), "qmc2.input", "qmc3.input")
	else:
		replace("numbblocks_input", str(numbblocks),          "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	replace("numbmolecules_input", str(numbmolecules),        "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	if (distance >= 0.0):
		replace("distanceArg_input", "DISTANCE",              "qmc2.input", "qmc3.input")
		call(["mv", "qmc3.input", "qmc2.input"])
		replace("distance_input", str(distance),              "qmc2.input", "qmc3.input")
	else:
		replace("distanceArg_input", "",                      "qmc2.input", "qmc3.input")
		call(["mv", "qmc3.input", "qmc2.input"])
		replace("distance_input", "",                         "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	replace("type_input", RotorType,                          "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	replace("molecule_input", str(molecule_rot),              "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	replace("level_input", str(level),                        "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	replace("dstep_input", str(step),                         "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	replace("dstep_tr_input", str(step_trans),                "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	if ((dipolemoment < 0.0) and (gfact < 0.0)):
		replace("dipolemomentArg_input", "",                  "qmc2.input", "qmc3.input")
		call(["mv", "qmc3.input", "qmc2.input"])
		replace("dipolemoment_input", "",                     "qmc2.input", "qmc3.input")
	else:
		if (dipolemoment >= 0.0):
			replace("dipolemomentArg_input", "DIPOLEMOMENT",  "qmc2.input", "qmc3.input")
			call(["mv", "qmc3.input", "qmc2.input"])
			replace("dipolemoment_input", str(dipolemoment),  "qmc2.input", "qmc3.input")

		if (gfact >= 0.0):
			replace("dipolemomentArg_input", "DIPOLEMOMENT",  "qmc2.input", "qmc3.input")
			call(["mv", "qmc3.input", "qmc2.input"])
			dipolemoment = GetDipoleMomentFromGFactor(molecule_rot, distance, gfact)
			replace("dipolemoment_input", str(dipolemoment),  "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	replace("numbpass_input", str(numbpass),                  "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	mcskip = numbbeads*numbpass
	#mcskip = numbpass
	replace("mskip_input", str(mcskip),                       "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	replace("numbparticle_input", str(particleA),             "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])

	if (crystal == True):
		replace("read_input", "READMCCOORDS",                 "qmc2.input", "qmc3.input")
	else:
		replace("read_input", "",                             "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])


	if Restart1:
		replace("job_input", "RESTART",                       "qmc2.input", "qmc3.input")
	else:
		replace("job_input", "START",                         "qmc2.input", "qmc3.input")
	call(["mv", "qmc3.input", "qmc2.input"])
	call(["mv", "qmc2.input", "qmc.input"])

def rotmat(TypeCal,molecule,temperature,numbbeads,source_dir_exe):
	'''
	This function generates rotational density matrix - linden.dat
	'''
	#temperature1    = dropzeros(temperature)
	temperature1    = "%5.3f" % temperature
	if (TypeCal == 'PIMC'):
		numbbeads1		= numbbeads
	else:
		numbbeads1		= numbbeads - 1
	command_linden_run = source_dir_exe+"linear_prop/linden.x "+str(temperature)+" "+str(numbbeads1)+" "+str(GetBconst(molecule))+" 15000 -1"
	system(command_linden_run)
	file_rotdens    = molecule+"_T"+str(temperature1)+"t"+str(numbbeads)+".rot"
	call(["mv", "linden.out", file_rotdens])

def GetTwoBodyDensity(Rpt, DipoleMoment, numbbeads, lmax, ltotalmax, tau, molecule):
	'''
	This function generates pair density of two body Hamiltonian
	command_line = "python script_PairDensityGenerator.py -d 1.0 -R 10.05 -P 20 -l-max 2 tau HF 0.2"
	system(command_line)
	'''
	srcCodePath         = "/home/tapas/DipoleChain.jl-master/examples/"
	Units               = GetUnitConverter()
	BConstant           = GetBconst(molecule)  # in wavenumber
	BConstantK          = BConstant*Units.CMRECIP2KL
	################################################################################
	RFactorList         = GetrAndgFactor(molecule, Rpt, DipoleMoment)
	RFactor             = RFactorList[0]
	tau    		        = tau*BConstantK
	if ltotalmax == 0:
		commandRun    		= "julia "+srcCodePath+"pair_density.jl -R "+str(RFactor)+" --l-max "+str(lmax)+" --tau "+str(tau)
	else:
		commandRun    		= "julia "+srcCodePath+"pair_density.jl -R "+str(RFactor)+" --l-max "+str(lmax)+" --l-total-max "+str(ltotalmax)+" --tau "+str(tau)
	system(commandRun)

def cagepot(source_dir_exe):
	'''
	This function generates tabulated potential - cagepot.dat
	'''
	command_cagepot_run = source_dir_exe+"tabulated_potential/hfc60.x 100 360"
	system(command_cagepot_run)
	file_cagepot    = "hfc60.pot"
	call(["mv", "cagepot.out", file_cagepot])

def jobstring_scratch(file_name, value, thread, run_dir, molecule, temperature, numbbeads, final_dir, dir_run_input_pimc,status_cagepot):
	'''
	This function creats jobstring for #PBS script
	'''
	if (thread > 4):
		thread = 4
	job_name       = "job_"+str(file_name)+str(value)
	walltime       = "200:00:00"
	processors     = "nodes=1:ppn="+str(thread)
	omp_thread     = str(thread)
	output_dir     = run_dir+"/results"
	temperature1   = "%5.3f" % temperature
	file_rotdens   = dir_run_input_pimc+"/"+molecule+"_T"+str(temperature1)+"t"+str(numbbeads)+".rot"
	logpath        = final_dir+"/"

	input_file     = dir_run_input_pimc+"/qmc"+file_name+str(value)+".input"
	exe_file       = dir_run_input_pimc+"/pimc"
	qmcinp         = "qmc"+file_name+str(value)+".input"

	job_string     = """#!/bin/bash
#PBS -N %s
#PBS -l walltime=%s
##PBS -q medium
#PBS -l %s
#PBS -o %s%s.out
#PBS -e %s%s.err
export OMP_NUM_THREADS=%s
rm -rf %s
mkdir -p %s
cd $PBS_O_WORKDIR
mv %s %s
mv %s %s 
cd %s
cp %s qmc.input
cp %s %s
./pimc
mv %s /work/tapas/linear_rotors
""" % (job_name, walltime, processors, logpath, job_name, logpath, job_name, omp_thread, run_dir, output_dir, input_file, run_dir, file_rotdens, run_dir, run_dir, qmcinp, exe_file, run_dir, run_dir)
	return job_string

def Submission(status, TransMove, RotMove, RUNDIR, dir_run_job, folder_run, src_dir, execution_file, Rpt, numbbeads, i, step, step_trans, level, temperature, numbblocks, numbpass, molecule_rot, numbmolecules, gfact, dipolemoment, TypeCal, dir_output, dir_run_input_pimc, RUNIN, particleA, NameOfPartition, status_cagepot, iStep, PPA1, user_name, out_dir, source_dir_exe, Restart1,numbblocks_Restart1,crystal,RotorType,Config,file1_name,Parallel):
	argument1     = Rpt
	level1        = level[iStep]
	step1         = step[iStep]
	step1_trans   = step_trans[iStep]

	ConfigInput   = []
	for iConfig in range(int(len(Config))):
		if (Parallel == False):
			iConfig = -1
			
		folder_run        = file1_name[iConfig+1]+str(numbbeads)
		final_dir_in_work = dir_output + folder_run
		if not Restart1:
			os.chdir(dir_output)
			if (os.path.isdir(folder_run) == True):
				print("")
				print("")
				print("Error message")
				print("")
				print("")
				printingMessage = "Remove "+str(dir_output)+str(folder_run)
				print(printingMessage)
				os.chdir(src_dir)
				return

			os.chdir(src_dir)
			if (RotorType == "LINEAR"):
				rotmat(TypeCal,molecule_rot,temperature,numbbeads,source_dir_exe)

				#call(["rm", "-rf", folder_run])
			temperature1    = "%5.3f" % temperature
			if (RotorType == "LINEAR"):
				file_rotdens    = molecule_rot+"_T"+str(temperature1)+"t"+str(numbbeads)+".rot"
				call(["mv", file_rotdens, dir_run_input_pimc[iConfig+1]])
			else:
				file_rotdens_rho = molecule_rot+"_T"+str(temperature1)+"t"+str(numbbeads)+".rho"
				call(["cp", file_rotdens_rho, dir_run_input_pimc[iConfig+1]])
				file_rotdens_eng = molecule_rot+"_T"+str(temperature1)+"t"+str(numbbeads)+".eng"
				call(["cp", file_rotdens_eng, dir_run_input_pimc[iConfig+1]])
				file_rotdens_esq = molecule_rot+"_T"+str(temperature1)+"t"+str(numbbeads)+".esq"
				call(["cp", file_rotdens_esq, dir_run_input_pimc[iConfig+1]])

			if (crystal == True):
				call(["cp", "LatticeConfig.xyz", dir_run_input_pimc[iConfig+1]])
		else:
			os.chdir(dir_output)
			if (os.path.isdir(folder_run) == False):
				print("")
				print("")
				print("Error message")
				print("")
				print("")
				printingMessage = str(dir_output)+str(folder_run)+" directory is absent."
				print(printingMessage)
				os.chdir(src_dir)
				return

		os.chdir(src_dir)
		GetInput(temperature,numbbeads,numbblocks,numbpass,molecule_rot,numbmolecules,argument1,level1,step1,step1_trans,gfact,dipolemoment,particleA, Restart1, numbblocks_Restart1, crystal, RotorType, TransMove, RotMove)

		input_file    = "qmcbeads"+str(i)+".input"
		call(["mv", "qmc.input", dir_run_input_pimc[iConfig+1]+"/"+input_file])
		folder_run_path = dir_run_job + folder_run 
	
		#job submission
		fname         = 'job-for-P'+str(numbbeads)
		if (TypeCal == 'PIGS'):
			argument2     = "pigs"+str(numbmolecules)+"b"
		if (TypeCal == 'PIMC'):
			argument2     = "pimc"+str(numbmolecules)+"b"
		if (TypeCal == 'ENT'):
			argument2     = "ent"+str(numbmolecules)+"a"+str(particleA)+"b"

		fwrite        = open(fname, 'w')

		if RUNDIR == "scratch":
			if RUNIN == "CPU":
				fwrite.write(jobstring_scratch_cpu(argument2,i,numbmolecules, folder_run_path, molecule_rot, temperature, numbbeads, final_dir_in_work, dir_run_input_pimc, src_dir, Restart1, dir_run_job,status_cagepot, dir_output))
			else:
				fwrite.write(jobstring_sbatch(RUNDIR, argument2,i,numbmolecules, folder_run_path, molecule_rot, temperature, numbbeads, final_dir_in_work, dir_run_input_pimc[iConfig+1], PPA1, user_name, out_dir, Restart1, dir_run_job,status_cagepot, dir_output,Parallel))
		else: 
			fwrite.write(jobstring_sbatch(RUNDIR, argument2, i, numbmolecules, folder_run_path, molecule_rot, temperature, numbbeads, final_dir_in_work, dir_run_input_pimc[iConfig+1], PPA1, user_name, out_dir, Restart1, dir_run_job,status_cagepot, dir_output,Parallel))

		fwrite.close()
		call(["mv", fname, dir_run_input_pimc[iConfig+1]])
		if (Parallel):
			InputPrint = "cd "+dir_run_input_pimc[iConfig+1]+"; sbatch "+fname
			ConfigInput.append(InputPrint)
		
	if (Parallel):
		fname_parallel_input = 'input-for-P'+str(numbbeads)
		f = open(dir_run_input_pimc[0]+"/"+fname_parallel_input, "w")
		f.write("\n".join(map(lambda x: str(x), ConfigInput)))
		f.close()

		fname_parallel_job = dir_run_input_pimc[0]+"/parallel-job-for-P"+str(numbbeads)
		f1 = open(fname_parallel_job, "w")
		f1.write(jobstring_sbatch_parallel(argument2+str(numbbeads)+"Config"+str(Config[iConfig]),fname_parallel_job, dir_run_input_pimc[0], fname_parallel_input))
		f1.close()
		
	os.chdir(dir_run_input_pimc[0])
	if (Parallel):
		call(["sbatch", fname_parallel_job])
		os.chdir(src_dir)
	else:
		if (RUNIN == "CPU"):
			call(["chmod", "755", fname])
			#command_pimc_run = "./"+fname + ">"+ final_dir_in_work+"/outpimc"+str(i)+" & "
			command_pimc_run = "./"+fname + ">outpimc"+str(i)+" & "
			print(command_pimc_run)
			system(command_pimc_run)
		else:
			#call(["qsub", fname])
			if (NameOfPartition == 'tapas'):
				call(["sbatch", "-p", "tapas", fname])
			else:
				call(["sbatch", fname])

		os.chdir(src_dir)

def jobstring_scratch_cpu(file_name, value, thread, run_dir, molecule, temperature, numbbeads, final_dir, dir_run_input_pimc, src_dir, Restart1, dir_run_job,status_cagepot, dir_output):
	'''
	This function creats jobstring for #PBS script
	'''
	omp_thread     = str(thread)
	output_dir     = run_dir+"/results"
	temperature1   = "%5.3f" % temperature
	file_rotdens   = dir_run_input_pimc+"/"+molecule+"_T"+str(temperature1)+"t"+str(numbbeads)+".rot"

	input_file     = dir_run_input_pimc+"/qmc"+file_name+str(value)+".input"
	exe_file       = dir_run_input_pimc+"/pimc"
	qmcinp         = "qmc"+file_name+str(value)+".input"

	job_string     = """#!/bin/bash
export OMP_NUM_THREADS=%s
rm -rf %s
mkdir -p %s
cd %s
mv %s %s
mv %s %s 
cd %s
cp %s qmc.input
cp %s %s
./pimc 
mv %s /work/tapas/linear_rotors
""" % (omp_thread, run_dir, output_dir, src_dir, input_file, run_dir, file_rotdens, run_dir, run_dir, qmcinp, exe_file, run_dir, run_dir)
	return job_string

def jobstring_sbatch(RUNDIR, file_name, value, thread, folder_run_path, molecule, temperature, numbbeads, final_dir_in_work, dir_run_input_pimc, PPA1, user_name, out_dir, Restart1, dir_run_job,status_cagepot, dir_output, Parallel):
	'''
	This function creats jobstring for #SBATCH script
	'''
	if (thread > 4):
		thread     = 4
	thread         = 1
	job_name       = file_name+str(value)
	walltime       = "28-00"
	omp_thread     = str(thread)
	output_dir     = folder_run_path+"/results"
	temperature1   = "%5.3f" % temperature
	file_rotdens   = dir_run_input_pimc+"/"+molecule+"_T"+str(temperature1)+"t"+str(numbbeads)+".*"
	logpath        = dir_run_input_pimc+"/"+job_name

	input_file     = dir_run_input_pimc+"/qmcbeads"+str(value)+".input"
	exe_file       = dir_run_input_pimc+"/pimc"
	qmcinp         = "qmcbeads"+str(value)+".input"
	if (status_cagepot == True):
		cagepot_file   = dir_run_input_pimc+"/hfc60.pot"
		cagepot_cp     = "cp "+cagepot_file+" "+folder_run_path
	else:
		cagepot_cp     = ""

	if (RUNDIR == "scratch"):
		CommandForMove = "mv "+folder_run_path+" "+dir_output
	if (RUNDIR == "work"):
		CommandForMove = " "
	CommandForMove = " " #for graham

	if not PPA1:
		CommandForPPA = "#"
	else:
		CommandForPPA = ""
	file_PPA       = dir_run_input_pimc+"/PairDensity.txt"
	print("")
	print("")
	print("")
	print("*****************Important Notice***********************")
	print("")
	print("Full path of the directory where the jobs are running - ")
	print(folder_run_path)
	print("")
	print("Full path of the directory where the outputs of MoRiBs are being stored during the jobs are running - ")
	print(output_dir)
	print("")
	print("Name of a file that gives acceptance ratio of Monte Carlo moves is - ")
	print(logpath+".out")
	print("")
	print("Number of OpenMP thread used = "+str(thread))
	print("")
	print("Path of the directory where output will be moved after completion is - ")
	print(final_dir_in_work)
	print("")
	print("********************************************************")
	print("")
	print("")
	print("")


	job_string     = """#!/bin/bash
#SBATCH --job-name=%s
#SBATCH --output=%s.out
#SBATCH --time=%s
#SBATCH --account=rrg-pnroy
#SBATCH --mem-per-cpu=2048mb
#SBATCH --cpus-per-task=%s
export OMP_NUM_THREADS=%s
rm -rf %s
mkdir -p %s
%s
mv %s %s
mv %s %s
mv %s %s
cd %s
cp %s qmc.input
cp %s %s
%s cp %s %s
####valgrind --leak-check=full -v --show-leak-kinds=all ./pimc 
time ./pimc 
%s
""" % (job_name, logpath, walltime, omp_thread, omp_thread, folder_run_path, output_dir, cagepot_cp, input_file, folder_run_path, file_rotdens, folder_run_path, "LatticeConfig.xyz", folder_run_path, folder_run_path, qmcinp, exe_file, folder_run_path, CommandForPPA, file_PPA, folder_run_path, CommandForMove)

	job_string_parallel     = """#!/bin/bash
export OMP_NUM_THREADS=%s
rm -rf %s
mkdir -p %s
%s
mv %s %s
mv %s %s
mv %s %s
cd %s
cp %s qmc.input
cp %s %s
%s cp %s %s
####valgrind --leak-check=full -v --show-leak-kinds=all ./pimc 
time ./pimc>%s
%s
""" % (omp_thread, folder_run_path, output_dir, cagepot_cp, input_file, folder_run_path, file_rotdens, folder_run_path, "LatticeConfig.xyz", folder_run_path, folder_run_path, qmcinp, exe_file, folder_run_path, CommandForPPA, file_PPA, folder_run_path, logpath, CommandForMove)

	job_string_restart = """#!/bin/bash
#SBATCH --job-name=%s
#SBATCH --output=%s.out
#SBATCH --time=%s
#SBATCH --account=rrg-pnroy
#SBATCH --mem-per-cpu=1200mb
#SBATCH --cpus-per-task=%s
export OMP_NUM_THREADS=%s
mv %s %s
mv %s %s
cd %s
cp %s qmc.input
####valgrind --leak-check=full -v --show-leak-kinds=all ./pimc 
time ./pimc 
%s
""" % (job_name, logpath, walltime, omp_thread, omp_thread,final_dir_in_work, dir_run_job, input_file, folder_run_path, folder_run_path, qmcinp, CommandForMove)

	if Restart1:
		return job_string_restart
	else:
		if (Parallel):	
			return job_string_parallel
		else:
			return job_string

def GetRotEnergy(molecule,jrot):
	Energy = GetBconst(molecule)*jrot*(jrot+1.0)
	return Energy

def GetAvgRotEnergy(molecule,beta):
	CMRECIP2KL = 1.4387672
	Zsum = 0.0
	Nsum = 0.0
	for jrot in range(0,10000,1):
		BoltzmannProb = exp(-beta*GetRotEnergy(molecule,jrot)*CMRECIP2KL)
		if (BoltzmannProb > 10e-16):
			Zsum += (2*jrot+1.0)*BoltzmannProb
			Nsum += (2*jrot+1.0)*GetRotEnergy(molecule,jrot)*BoltzmannProb
		else:
			break
	AvgEnergy = Nsum*CMRECIP2KL/Zsum
	return AvgEnergy

def GetFileNameSubmission(TypeCal, molecule_rot, TransMove, RotMove, Rpt, gfact, dipolemoment, parameterName, parameter, numbblocks, numbpass, numbmolecules, molecule, ENT_TYPE, particleA, extra, crystal,Config, Parallel):
	add                     = ""
	if (TypeCal == "ENT"):
		add1                = "-ParticleA"+str(particleA)
		add2                = "-"
	else:
		add1                = ""
		add2                = ""

	if (crystal == True):
		mainFileName        = parameterName+str(parameter)+"Kinv-Blocks"+str(numbblocks)+"-Passes"+str(numbpass)+add+"-System"+str(molecule)+add1+"-e0vsbeads"+add2 
	else:
		mainFileName        = parameterName+str(parameter)+"Kinv-Blocks"+str(numbblocks)+"-Passes"+str(numbpass)+add+"-System"+str(numbmolecules)+str(molecule)+add1+"-e0vsbeads"+add2 

	if (TypeCal == "PIGS"):
		frontName           = "PIGS-"
	if (TypeCal == "PIMC"):
		frontName           = "PIMC-"
	if (TypeCal == "ENT"):
		frontName           = "ENT-"

	frontName              += extra

	if ((TransMove == True) and (RotMove == True)):
		frontName      += "TransAndRotDOFs-"
	if ((TransMove == False) and (RotMove == True)):
		frontName      += "RotDOFs-"
	if ((TransMove == True) and (RotMove == False)):
		frontName      += "TransDOFs-"


	if (Rpt >= 0.0):
		FragmentRpt = "Rpt"+str(Rpt)+"Angstrom-"
	else:
		FragmentRpt = ""

	if (dipolemoment >= 0.0):
		FragmentDipoleMoment = "DipoleMoment"+str(dipolemoment)+"Debye-"
	else:
		FragmentDipoleMoment = ""

	if (gfact >= 0.0):
		FragmentGFactor = "gFactor"+str(gfact)+"-"
	else:
		FragmentGFactor = ""

	file_name      = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+mainFileName
	if (TypeCal == "ENT"):
		file_name += ENT_TYPE
	
	file_name_submit = []
	file_name_submit.append(file_name)
	if (Parallel):
		for i in range(int(len(Config))):
			file_name_submit.append(file_name+str(Config[i])+'Config')
	return file_name_submit

class GetFileNameAnalysis:
	def __init__(self, TypeCal1,TypeCal2, molecule_rot1, TransMove1, RotMove1, variableName1, Rpt1, gfact1, dipolemoment1, parameterName1, parameter1, numbblocks1, numbpass1, numbmolecules1, molecule1, ENT_TYPE1, preskip1, postskip1, extra1, src_dir1, particleA1):
		self.TypeCal      = TypeCal1
		self.molecule_rot = molecule_rot1
		self.TransMove    = TransMove1
		self.RotMove      = RotMove1
		self.variableName = variableName1
		self.Rpt          = Rpt1
		self.dipolemoment = dipolemoment1
		self.gfact        = gfact1
		self.parameter    = parameter1
		self.parameterName= parameterName1
		self.numbblocks   = numbblocks1
		self.numbpass     = numbpass1
		self.numbmolecules= numbmolecules1
		self.molecule     = molecule1
		self.ENT_TYPE     = ENT_TYPE1
		self.preskip      = preskip1
		self.postskip     = postskip1
		self.extra        = extra1
		self.src_dir      = src_dir1
		self.particleA    = particleA1
		print("#------------------------------------------------------------------------#")
		print("Final analyzed results are being stored in the below mentioned directory - ")


		if (self.TypeCal == "ENT"):
			frontName             = "ENT-"+self.extra
			add1                  = "-ParticleA"+str(self.particleA)
			add2                  = "-"+self.ENT_TYPE
		else:
			frontName             = self.TypeCal+"-"+self.extra
			add1                  = ""
			add2                  = ""

		if ((self.TransMove == True) and (self.RotMove == True)):
			frontName            += "TransAndRotDOFs-"
		if ((self.TransMove == False) and (self.RotMove == True)):
			frontName            += "RotDOFs-"
		if ((self.TransMove == True) and (self.RotMove == False)):
			frontName            += "TransDOFs-"

		if (self.Rpt >= 0.0):
			FragmentRpt           = "Rpt"+str(self.Rpt)+"Angstrom-"
		else:
			FragmentRpt           = ""

		if (self.dipolemoment >= 0.0):
			FragmentDipoleMoment  = "DipoleMoment"+str(self.dipolemoment)+"Debye-"
		else:
			FragmentDipoleMoment  = ""

		if (self.gfact >= 0.0):
			FragmentGFactor       = "gFactor"+str(self.gfact)+"-"
		else:
			FragmentGFactor       = ""

		mainFileName  = "vs-"+str(self.variableName)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv-Blocks"+str(self.numbblocks)
		mainFileName += "-Passes"+str(self.numbpass)+"-System"+str(self.numbmolecules)+str(self.molecule)+add1+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)+add2

		file_output1  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Energy-"	
		file_output2  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"correlation-"
		file_output3  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"total-correlation-function-"
		file_output4  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"X-component-correlation-function-"
		file_output5  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Y-component-correlation-function-"
		file_output6  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Z-component-correlation-function-"
		file_output7  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"XandY-component-correlation-function-"
		file_output8  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Entropy-"

		self.SaveEnergy       = self.src_dir+file_output1+mainFileName+".txt"
		self.SaveCorr         = self.src_dir+file_output2+mainFileName+".txt"
		self.SaveTotalCorr    = self.src_dir+file_output3+mainFileName+".txt"
		self.SaveXCorr        = self.src_dir+file_output4+mainFileName+".txt"
		self.SaveYCorr        = self.src_dir+file_output5+mainFileName+".txt"
		self.SaveZCorr        = self.src_dir+file_output6+mainFileName+".txt"
		self.SaveXYCorr       = self.src_dir+file_output7+mainFileName+".txt"
		self.SaveEntropy      = self.src_dir+file_output8+mainFileName+".txt"

		if (TypeCal2 == False):
			if os.path.exists(self.SaveEntropy):   os.remove(self.SaveEntropy)
			if os.path.exists(self.SaveEnergy):    os.remove(self.SaveEnergy)
			if os.path.exists(self.SaveCorr):      os.remove(self.SaveCorr)
			if os.path.exists(self.SaveTotalCorr): os.remove(self.SaveTotalCorr)
			if os.path.exists(self.SaveXCorr):     os.remove(self.SaveXCorr)
			if os.path.exists(self.SaveYCorr):     os.remove(self.SaveYCorr)
			if os.path.exists(self.SaveZCorr):     os.remove(self.SaveZCorr)
			if os.path.exists(self.SaveXYCorr):    os.remove(self.SaveXYCorr)

		if (self.TypeCal != "ENT"):
			print(self.src_dir)
			print("")
			print("Final results - Energy vs "+str(self.variableName))
			print(file_output1+mainFileName+".txt")
			print("#------------------------------------------------------------------------#")

		if (self.TypeCal == "ENT"):
			mainFileNameRT    = "vs-"+str(self.variableName)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv-Blocks"+str(self.numbblocks)
			mainFileNameRT   += "-Passes"+str(self.numbpass)+"-System"+str(self.numbmolecules)+str(self.molecule)+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)+add2

			self.SaveEntropyRT= self.src_dir+file_output8+mainFileNameRT+".txt"
			print(self.src_dir)
			print("")
			print("Final results - Entropy vs "+str(self.variableName))
			print(self.SaveEntropyRT)
			print("#------------------------------------------------------------------------#")

class GetFileNamePlot:
	def __init__(self, TypeCal1, molecule_rot1, TransMove1, RotMove1, variableName1, Rpt1, gfact1, dipolemoment1, parameterName1, parameter1, numbblocks1, numbpass1, numbmolecules1, molecule1, ENT_TYPE1, preskip1, postskip1, extra1, src_dir1, particleA1, var1):
		self.TypeCal      = TypeCal1
		self.molecule_rot = molecule_rot1
		self.TransMove    = TransMove1
		self.RotMove      = RotMove1
		self.variableName = variableName1
		self.var          = var1
		self.Rpt          = Rpt1
		self.dipolemoment = dipolemoment1
		self.gfact        = gfact1
		self.parameter    = parameter1
		self.parameterName= parameterName1
		self.numbblocks   = numbblocks1
		self.numbpass     = numbpass1
		self.numbmolecules= numbmolecules1
		self.molecule     = molecule1
		self.ENT_TYPE     = ENT_TYPE1
		self.preskip      = preskip1
		self.postskip     = postskip1
		self.extra        = extra1
		self.src_dir      = src_dir1
		self.particleA    = particleA1

		if (self.TypeCal == "ENT"):
			frontName             = "ENT-"+self.extra
			add1                  = "-ParticleA"+str(self.particleA)
			add2                  = "-"+self.ENT_TYPE
		else:
			frontName             = self.TypeCal+"-"+self.extra
			add1                  = ""
			add2                  = ""

		if ((self.TransMove == True) and (self.RotMove == True)):
			frontName            += "TransAndRotDOFs-"
		if ((self.TransMove == False) and (self.RotMove == True)):
			frontName            += "RotDOFs-"
		if ((self.TransMove == True) and (self.RotMove == False)):
			frontName            += "TransDOFs-"

		if (self.Rpt >= 0.0):
			FragmentRpt           = "Rpt"+str(self.Rpt)+"Angstrom-"
		else:
			FragmentRpt           = ""

		if (self.dipolemoment >= 0.0):
			FragmentDipoleMoment  = "DipoleMoment"+str(self.dipolemoment)+"Debye-"
		else:
			FragmentDipoleMoment  = ""

		if (self.gfact >= 0.0):
			FragmentGFactor       = "gFactor"+str(self.gfact)+"-"
		else:
			FragmentGFactor       = ""

		mainFileName  = "vs-"+str(self.variableName)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv-Blocks"+str(self.numbblocks)
		mainFileName += "-Passes"+str(self.numbpass)+"-System"+str(self.numbmolecules)+str(self.molecule)+add1+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)+add2

		file_output1  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Energy-"
		file_output2  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"correlation-"
		file_output3  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"total-correlation-function-"
		file_output4  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"X-component-correlation-function-"
		file_output5  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Y-component-correlation-function-"
		file_output6  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Z-component-correlation-function-"
		file_output7  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"XandY-component-correlation-function-"
		file_output8  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Chemical-Potential-"
		file_output9  = frontName+FragmentRpt+FragmentDipoleMoment+FragmentGFactor+"Entropy-"

		self.SaveEnergy       = self.src_dir+file_output1+mainFileName
		self.SaveCorr         = self.src_dir+file_output2+mainFileName
		self.SaveTotalCorr    = self.src_dir+file_output3+mainFileName
		self.SaveXCorr        = self.src_dir+file_output4+mainFileName
		self.SaveYCorr        = self.src_dir+file_output5+mainFileName
		self.SaveZCorr        = self.src_dir+file_output6+mainFileName
		self.SaveXYCorr       = self.src_dir+file_output7+mainFileName
		self.SaveChemPot      = self.src_dir+file_output8+mainFileName
		self.SaveEntropy      = self.src_dir+file_output9+mainFileName

#---------------------------------------------------------------------------#
#	special cases                                                           #
#---------------------------------------------------------------------------#
		'''
		mainFileNameCP        = "vs-number-of-"+str(self.molecule)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv-Blocks"+str(self.numbblocks)
		mainFileNameCP       += "-Passes"+str(self.numbpass)+add1+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)
		mainFileNameCONV      = "vs-beta-and-tau-Blocks"+str(self.numbblocks)
		mainFileNameCONV     += "-Passes"+str(self.numbpass)+"-System"+str(self.numbmolecules)+str(self.molecule)+add1+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)
		self.SaveChemPot      = self.src_dir+file_output8+mainFileNameCP
		self.SaveEntropyCONV  = self.src_dir+"/ResultsOfPIGSENT/"+file_output1+mainFileNameCONV+"-"+self.ENT_TYPE

		'''
#
		mainFileNameGFAC      = "vs-gFactor-of-"+str(self.molecule)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv-numbbeads"+str(self.var)+"-Blocks"+str(self.numbblocks)
		mainFileNameGFAC     += "-Passes"+str(self.numbpass)+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)+add2
#
		mainFileNameRFAC      = "vs-RFactor-of-"+str(self.molecule)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv-numbbeads"+str(self.var)+"-Blocks"+str(self.numbblocks)
		mainFileNameRFAC     += "-Passes"+str(self.numbpass)+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)+add2
		mainFileNameMM 		  = "vs-"+str(self.variableName)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv"
		mainFileNameMM       += "-System"+str(self.numbmolecules)+str(self.molecule)+add1
		mainFileNameCOMBO     = "vs-gFactor-of-"+str(self.molecule)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv-numbbeads"+str(self.var)+"-Blocks"+str(self.numbblocks)
		mainFileNameCOMBO    += "-Passes"+str(self.numbpass)+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)
#
		self.SaveEntropyGFAC  = self.src_dir+frontName+FragmentRpt+"Entropy-"+mainFileNameGFAC
		self.SaveEntropyRFAC  = self.src_dir+frontName+FragmentRpt+"Entropy-"+mainFileNameRFAC
		self.SaveEnergyGFAC   = self.src_dir+frontName+FragmentRpt+"Energy-"+mainFileNameGFAC
		self.SaveEnergyRFAC   = self.src_dir+frontName+FragmentRpt+"Energy-"+mainFileNameRFAC
		self.SaveEnergyDIAG   = self.src_dir+file_output1+mainFileNameMM+add2+"-DIAG"
		self.SaveEntropyDIAG  = self.src_dir+file_output9+mainFileNameMM+add2+"-DIAG"
		self.SaveCorrGFAC     = self.src_dir+frontName+FragmentRpt+"correlation-"+mainFileNameGFAC
		self.SaveCorrRFAC     = self.src_dir+frontName+FragmentRpt+"correlation-"+mainFileNameRFAC
		self.SaveEnergyMM     = self.src_dir+file_output1+mainFileNameMM+add2+"-MM"
		self.SaveEntropyMM    = self.src_dir+file_output9+mainFileNameMM+add2+"-MM"
		self.SaveEntropyCOMBO = self.src_dir+frontName+FragmentRpt+"Entropy-"+mainFileNameCOMBO+"-COMBINE"

		if (self.TypeCal == "ENT"):
			mainFileNameRT    = "vs-"+str(self.variableName)+"-fixed-"+self.parameterName+str(self.parameter)+"Kinv-Blocks"+str(self.numbblocks)
			mainFileNameRT   += "-Passes"+str(self.numbpass)+"-System"+str(self.numbmolecules)+str(self.molecule)+"-preskip"+str(self.preskip)+"-postskip"+str(self.postskip)+add2

			self.SaveEntropyRT= self.src_dir+file_output9+mainFileNameRT

def FileCheck(TypeCal,list_nb,variableName,SavedFile):
	for i in list_nb:
		if (TypeCal == "PIMC"):
			if ((i%2) == 0):
				bead = i
			else:
				bead = i+1
		else:
			if ((i%2) != 0):
				bead = i
			else:
				bead = i+1

		string = str(bead)
		if string in open(SavedFile).read():
			return

	if not string in open(SavedFile).read():
		call(["rm", SavedFile])

class GetUnitConverter:
	def __init__(self):
		self.BOHRRADIUS = 0.5291772108;      # angstrom
		self.HARTREE2JL = 4.359748e-18;    	# hartree to joule  conversion factor
		self.HARTREE2KL = 3.157732e+05;    	# hartree to Kelvin conversion factor
		self.CMRECIP2KL = 1.4387672;       	# cm^-1 to Kelvin conversion factor
		self.MHZ2RCM    = 3.335640952e-5;  	# MHz to cm^-1 conversion factor

		self.AuToDebye     = 1.0/0.39343;
		self.AuToCmInverse = 219474.63137;
		self.AuToKelvin    = 315777.0;
		self.KCalperMolToCmInverse = 349.75509;

		self.HBAR  = 1.05457266; 			#  (10^-34 Js)     Planck constant
		self.AMU   = 1.6605402;  			#  (10^-27 kg)     atomic mass unit
		self.K_B   = 1.380658;   			#  (10^-23 JK^-1)  Boltzmann constant
		self.WNO2K = 0.6950356; 				# conversion from CM-1 to K

def GetrAndgFactor(molecule, RCOM, DipoleMoment):
	'''
	It calculates g and R value 
	'''
	Units          = GetUnitConverter()
	BConstant      = GetBconst(molecule)  # in wavenumber
	DipoleMomentAU = DipoleMoment/Units.AuToDebye
	RCOMAU         = RCOM/Units.BOHRRADIUS
	BConstantAU    = BConstant/Units.AuToCmInverse
	rFactor        = RCOMAU/((DipoleMomentAU*DipoleMomentAU/BConstantAU)**(1.0/3.0))
	gFactor        = (DipoleMomentAU*DipoleMomentAU)/(RCOMAU*RCOMAU*RCOMAU*BConstantAU)
	printingmessage   = " DipoleMoment = "+str(DipoleMoment)+" gFactor = " + str(gFactor)+ " rFactor = "+str(rFactor)
	print(printingmessage)
	returnList = [rFactor, gFactor]
	return returnList

def GetDipoleMomentFromGFactor(molecule, RCOM, gFactor):
	'''
	It extracts dipole moment from a g value - g 
	'''
	Units          = GetUnitConverter()
	BConstant      = GetBconst(molecule)  # in wavenumber
	RCOMAU         = RCOM/Units.BOHRRADIUS
	BConstantAU    = BConstant/Units.AuToCmInverse
	DipoleMomentAU = sqrt(gFactor*RCOMAU*RCOMAU*RCOMAU*BConstantAU)
	DipoleMoment   = DipoleMomentAU*Units.AuToDebye
	return DipoleMoment

def GetExactValues(FilePlotName, srcCodePath, RFactor, numbmolecules, loop, particleA, molecule_rot, Rpt, dipolemoment, parameter, BConstantK, variableName, TypeCal):
	if (TypeCal == "ENT"):
		FileToBeSavedDIAG = FilePlotName.SaveEntropyDIAG+".txt"
		FileToBeSavedMM = FilePlotName.SaveEntropyMM+".txt"
	if (TypeCal == "PIGS"):
		FileToBeSavedDIAG = FilePlotName.SaveEnergyDIAG+".txt"
		FileToBeSavedMM = FilePlotName.SaveEnergyMM+".txt"

	commandRunDIAG    = "julia "+srcCodePath+"diagonalization.jl -R "+str(RFactor)+" -N "+str(numbmolecules)+" --l-max 8 --l-total-max 8 --A-start 1"+" --A-size "+str(particleA)
	call(["rm", "outputDIAG.txt"])
	system(commandRunDIAG)
	call(["mv", "outputDIAG.txt", FileToBeSavedDIAG])
	if (numbmolecules >6):
		print("It is not computing Matrix multiplication stuffs")
		return

	'''
	if (numbmolecules <= 4):
		call(["rm", "outputMM.txt"])

		for numbbeads in loop:
			print(numbbeads)
			RFactor      = GetrAndgFactor(molecule_rot, Rpt, dipolemoment)
			if (variableName == "beta"):
				parameterR    = parameter*BConstantK
				commandRun   = "julia "+srcCodePath+"path_integral.jl -R "+str(RFactor)+" -N "+str(numbmolecules)+" --l-max 6 --tau "+str(parameterR)+" -P "+str(numbbeads)+" --pigs --A-start 1"+" --A-size "+str(particleA)
			if (variableName == "tau"):
				parameterR    = parameter*BConstantK
				commandRun   = "julia "+srcCodePath+"path_integral.jl -R "+str(RFactor)+" -N "+str(numbmolecules)+" --l-max 6 --beta "+str(parameterR)+" -P "+str(numbbeads)+" --pigs --A-start 1"+" --A-size "+str(particleA)
			system(commandRun)
		call(["mv", "outputMM.txt", FileToBeSavedMM])
	'''

def GetPairDensity(FilePlotName, srcCodePath, RFactor, numbmolecules, loop, particleA, molecule_rot, Rpt, dipolemoment, parameter, BConstantK, variableName, TypeCal):
	FileToBeSavedDensity = FilePlotName+".txt"
	for numbbeads in loop:
		print(numbbeads)
		parameterR    = parameter*BConstantK
		commandRun    = "julia "+srcCodePath+"pair_density.jl -R "+str(RFactor)+" --l-max 2 --l-total-max 2 --tau "+str(parameterR)
		print(commandRun)
		call(["rm", "outputDensity.txt"])
		system(commandRun)
		call(["mv", "outputDensity.txt", FileToBeSavedDensity])

def GetEntropyRT(status, maxloop, TypeCal, molecule_rot, TransMove, RotMove, variableName, Rpt, gfact, dipolemoment, parameterName, parameter, numbblocks, numbpass, numbmolecules1, molecule, ENT_TYPE, preskip, postskip, extra_file_name, final_results_path, particleA, variable):
	#FileAnalysis = GetFileNameAnalysis(TypeCal, True, molecule_rot, TransMove, RotMove, variableName, Rpt, gfact, dipolemoment, parameterName, parameter, numbblocks, numbpass, numbmolecules1, molecule, ENT_TYPE, preskip, postskip, extra_file_name, final_results_path, particleA)
	GetAverageEntropyRT(maxloop, TypeCal, molecule_rot, TransMove, RotMove, variableName, Rpt, gfact, dipolemoment, parameterName, parameter, numbblocks, numbpass, numbmolecules1, molecule, ENT_TYPE, preskip, postskip, extra_file_name, final_results_path, particleA, variable)

def GetPreFactDDPot(molecule, RCOM, DipoleMoment):
	'''
	It calculates the pre factor in inverse temperature of dipole - dipole interaction potential
	'''
	Units          = GetUnitConverter()
	DipoleMomentAU = DipoleMoment/Units.AuToDebye
	RCOMAU         = RCOM/Units.BOHRRADIUS
	preFact        = (DipoleMomentAU*DipoleMomentAU)/(RCOMAU*RCOMAU*RCOMAU)
	preFact        = preFact*Units.HARTREE2KL
	printingmessage= " DipoleMoment = "+str(DipoleMoment)+" Debye and the prefactor of the dipole-dipole interaction potential = " + str(preFact)+ " K^-1"
	print(printingmessage)

def jobstring_sbatch_parallel(file_name, logfile, dir_run_input_pimc, input_file):
	'''
	This function creats jobstring for #SBATCH script
	'''
	job_name       = file_name
	walltime       = "00:30:00"
	logpath        = logfile

	job_string     = """#!/bin/bash
#SBATCH --job-name=%s
#SBATCH --output=%s.out
#SBATCH --time=%s
#SBATCH --account=rrg-pnroy
#SBATCH --mem-per-cpu=1048mb
cd %s
parallel --jobs 0 < %s 
""" % (job_name, logpath, walltime, dir_run_input_pimc, input_file)

	print(job_string)
	return job_string
